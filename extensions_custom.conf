[globals]
FORWARD_SECRET=%FORWARD_SECRET%
PHONE_ID=%PHONE_ID%
FORWARD_URL=%FORWARD_URL%
CALL_FORWARD_URL=%CALL_FORWARD_URL%

[incoming-mobile]
; 如果事件是短信 (exten=sms)，则跳转到 [from-quectel-sms] 上下文
exten => sms,1,Goto(from-quectel-sms,sms,1)

; 如果事件是USSD码 (exten=ussd)，则跳转到 [from-quectel-ussd] 上下文
exten => ussd,1,Goto(from-quectel-ussd,ussd,1)

; 如果是任何其他号码 (即来电)，则跳转到 [from-quectel-call] 上下文
exten => _.,1,Goto(from-quectel-call,${EXTEN},1)

; ====================================================================
;  上下文: from-quectel-sms
;  职责: 专门处理短信
; ====================================================================
[from-quectel-sms]
exten => sms,1,Verbose(Incoming SMS from ${CALLERID(num)})
exten => sms,n,System(echo '${STRFTIME(${EPOCH},,%Y-%m-%d %H:%M:%S)} - ${QUECTELNAME} - ${CALLERID(num)}: ${BASE64_DECODE(${SMS_BASE64})}' >> /data/log/sms.txt)
exten => sms,n,Set(SMS_TEXT=${BASE64_DECODE(${SMS_BASE64})})
exten => sms,n,Set(SMS_TIME=${STRFTIME(${EPOCH},,%Y-%m-%dTH:%M:%S%z)})
exten => sms,n,Set(SMS_ID=${EPOCH}-${RAND()})
exten => sms,n,NoOp(Attempting to read phone number from channel variable ${QUECTELNUMBER})
exten => sms,n,Set(MODEM_NUMBER=${QUECTELNUMBER})
exten => sms,n,NoOp(Modem number read from variable: ${MODEM_NUMBER})
exten => sms,n,Set(FORWARDING_ID=${IF($[ $[ "${MODEM_NUMBER}" = "" ] | $[ "${MODEM_NUMBER}" = "Unknown" ] ]?${PHONE_ID}:${MODEM_NUMBER})})
exten => sms,n,NoOp(Final forwarding ID being used: ${FORWARDING_ID})
exten => sms,n,System(echo "${SMS_TEXT}" | /usr/local/bin/forward_sms.php ${FORWARD_SECRET} ${CALLERID(num)} "${SMS_TIME}" ${FORWARDING_ID} ${SMS_ID} ${FORWARD_URL})
exten => sms,n,Hangup()

; ====================================================================
;  上下文: from-quectel-ussd
;  职责: 专门处理USSD
; ====================================================================
[from-quectel-ussd]
exten => ussd,1,Verbose(Incoming USSD: ${BASE64_DECODE(${USSD_BASE64})})
exten => ussd,n,System(echo '${STRFTIME(${EPOCH},,%Y-%m-%d %H:%M:%S)} - ${QUECTELNAME}: ${BASE64_DECODE(${USSD_BASE64})}' >> /data/log/ussd.txt)
exten => ussd,n,Hangup()

; ====================================================================
;  上下文: from-quectel-call
;  职责: 专门处理语音来电
; ====================================================================
[from-quectel-call]
exten => _.,1,Verbose(Incoming Call from ${CALLERID(num)})
same => n,Set(CALLERID(name)=${CALLERID(num)})
same => n,Set(CALL_TIME=${STRFTIME(${EPOCH},,%Y-%m-%dT%H:%M:%S%z)})
same => n,Set(CALL_ID=${EPOCH}-${RAND()})
same => n,NoOp(Attempting to read phone number from channel variable ${QUECTELNUMBER})
same => n,Set(MODEM_NUMBER=${QUECTELNUMBER})
same => n,NoOp(Modem number read from variable: ${MODEM_NUMBER})
same => n,Set(FORWARDING_ID=${IF($[ $[ "${MODEM_NUMBER}" = "" ] | $[ "${MODEM_NUMBER}" = "Unknown" ] ]?${PHONE_ID}:${MODEM_NUMBER})})
same => n,NoOp(Final forwarding ID being used: ${FORWARDING_ID})
same => n,Set(CALL_JSON_DATA={\\"secret\\":\\"${FORWARD_SECRET}\\",\\"number\\":\\"${CALLERID(num)}\\",\\"name\\":\\"${CALLERID(name)}\\",\\"time\\":\\"${CALL_TIME}\\",\\"type\\":\\"incoming_call\\",\\"duration\\":0,\\"source\\":\\"asterisk\\",\\"phone_id\\":\\"${FORWARDING_ID}\\",\\"timestamp\\":\\"${CALL_TIME}\\"})
;same => n,System(nohup sh -c 'echo "${CALL_JSON_DATA}" | curl -s -X POST -H "Content-Type: application/json" -H "User-Agent: Asterisk-Chan-Quectel/1.0" -d @- --connect-timeout 5 --max-time 10 ${CALL_FORWARD_URL} >> /var/log/asterisk/call_forward.log 2>&1 &')
same => n,System(nohup sh -c 'echo "${CALL_JSON_DATA}" | curl -s -X POST -H "Content-Type: application/json" -H "User-Agent: Asterisk-Chan-Quectel/1.0" -d @- --connect-timeout 5 --max-time 10 ${CALL_FORWARD_URL} ; echo' >> /var/log/asterisk/call_forward.log 2>&1 &)
same => n,Goto(from-trunk,${EXTEN},1)

; ====================================================================
;  用于接收来自 Go 服务的 API 请求以发送带特殊字符的短信 (弃用）
; ====================================================================
[sms-from-api]

; s,1: 当本地通道进入这个上下文时执行
; NoOp 用于在 Asterisk CLI 中打印日志，方便调试
exten => s,1,NoOp(Received API SMS request for ${RECIPIENT} via device ${DEVICE})

; s,n: 使用 BASE64_DECODE 函数解码消息内容
exten => s,n,Set(DECODED_MESSAGE=${BASE64_DECODE(${MSG_B64})})

; s,n: 再次打印日志，验证解码后的消息是否正确（包含换行符）
exten => s,n,NoOp(Decoded message content: ${DECODED_MESSAGE})

; We "pipe" the decoded message into the script's standard input.
exten => s,n,System(echo "${DECODED_MESSAGE}" | /usr/local/bin/send_sms_wrapper.sh "${DEVICE}" "${RECIPIENT}")

; s,n: 挂断本地通道，结束流程
exten => s,n,Hangup()
